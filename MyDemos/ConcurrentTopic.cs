using System.Collections.Concurrent;

public class ConcurrentTopic
{
    //ensuring thread safety while enabling parallelism
    //offers a collection of thread-safe data structures designed for use in multi-threaded applications.

    //The ConcurrentQueue class primarily facilitates data management across multiple threads, eliminating the need for explicit synchronization mechanisms.
    //ConcurrentQueue ensures safe enqueueing and dequeuing operations from different threads, preventing data corruption and race conditions.

    //In addition to the ConcurrentQueue class, the System.Collections.Concurrent namespace provides other thread-safe collections,
    //such as ConcurrentDictionary, ConcurrentBag, and ConcurrentStack classes.

    //Multi-threaded data management introduces several challenges that can lead to data access issues, race conditions, and even data corruption.
    //These challenges arise when multiple threads attempt to read, write, or modify data simultaneously.
    //Data corruption as a result of simultaneous writes to shared data without proper synchronization
    //The ConcurrentQueue class utilizes lock-free algorithms to manage concurrent enqueue and dequeue operations efficiently. 
    public void UseConcurrentQueue()
    {
        ConcurrentQueue<int> myQueue = new ConcurrentQueue<int>([1, 2, 4, 5]);
        myQueue.Enqueue(5);

        for (int i = 0; i < 10000; i++)
        {
            myQueue.Enqueue(i);
        }

        if (myQueue.TryDequeue(out var item))
        {
            // Process item
        }

        foreach (var el in myQueue)
        {
            // Process el
        }

        Console.WriteLine(myQueue.Count);
        myQueue.Clear();
    }

    public void UseConcurrentDictionary()
    {
        ConcurrentDictionary<Type, IEnumerable<string>> result = new();
        result.AddOrUpdate(typeof(int), (key, value) => [value], (key, features, value) => features.Contains(value) ? features : features.Append(value).ToArray(), "");

    }
}